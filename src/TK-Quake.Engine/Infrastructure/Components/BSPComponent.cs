using System;
using System.Collections.Generic;
using System.IO;
using System.Drawing;
using System.Drawing.Imaging;
using System.Linq;
using OpenTK;
using OpenTK.Graphics.OpenGL4;
using TKQuake.Engine.Core;
using TKQuake.Engine.Loader;
using TKQuake.Engine.Loader.BSP;
using TKQuake.Engine.Infrastructure.Entities;
using TKQuake.Engine.Infrastructure.Math;
using TKQuake.Engine.Infrastructure.Texture;
using PixelFormat = OpenTK.Graphics.OpenGL4.PixelFormat;
using Vertex = TKQuake.Engine.Infrastructure.Math.Vertex;
using TKQuake.Engine.Infrastructure.Physics;

namespace TKQuake.Engine.Infrastructure.Components
{
    public class BSPComponent : IComponent
    {
        // Some small amount used for offsetting in collision detection.
        private const float EPSILON = 1/32.0f;

        // The base ID for every mesh that is generated by this component.
        private const string ENTITY_ID = "BSP";

        // The system renderer.
        private readonly Renderer _renderer = Renderer.Singleton();

        // The system texture manager.
        private readonly TextureManager texManager = TextureManager.Singleton ();

        // The BSP loader and renderer.
        private BSPLoader loader;
        private BSPRenderer renderer;

        // The total number of meshes in the current BSP file.
        private int totalMeshes;

        // The renderable entities.
        Dictionary<int, List<RenderableEntity>> BSPEntities;

        // The camera.
        private Camera camera;
        private Vector3 previousCameraPosition;

        private BSPComponent()
        {
            camera = null;
            previousCameraPosition = Vector3.Zero;
            loader = null;
            renderer = null;
            totalMeshes = 0;
            BSPEntities = null;
        }

        /// <summary>
        /// Construct the BSPComponent.
        /// </summary>
        /// <param name="BSPFile">The BSP file to render.</param>
        /// <param name="camera">The camera.</param>
        public BSPComponent(string BSPFile, ref Camera cam) : this()
        {
            camera = cam;
            previousCameraPosition = camera.Position;
            ChangeBSP (BSPFile);
        }

        /// <summary>
        /// Loads a new BSP file for rendering.
        /// </summary>
        /// <param name="BSPFile">The BSP file to render.</param>
        public void ChangeBSP(string BSPFile)
        {
            // Make sure there are no meshes or textures loaded from the previous BSP file.
            UnloadAllMeshes();
            UnloadAllTextures();

            // Create the new loader and parse the file.
            loader = new BSPLoader(BSPFile, true);
            loader.ParseFile ();

            // TODO: This can be removed once "debugging" is finished.
            loader.DumpBSP ();

            // Create the new renderer.
            renderer = new BSPRenderer(loader);

            // Load all of the textures and meshes for the current BSP file.
            // Order is important here.
            LoadAllTextures();
            LoadAllMeshes();
        }

        public void Startup() { }
        public void Shutdown()
        {
            // Make sure there are no meshes or textures loaded from the previous BSP file.
            UnloadAllMeshes();
            UnloadAllTextures();
        }

        /// <summary>
        /// Render all of the faces that are visible from the current camera position.
        /// </summary>
        /// <param name="elapsedTime">Not used.</param>
        public void Update(double elapsedTime)
        {
            BoundingBoxEntity box = camera.Children.OfType<BoundingBoxEntity>().FirstOrDefault();
            Vector3 pos = CheckBoxCollisions(previousCameraPosition, camera.Position, box.Bottom, box.Top);

            camera.Position = pos;
            previousCameraPosition = camera.Position;

            var visibleFaces = BSPEntities.Keys;
            foreach (var face in visibleFaces)
            {
                BSPEntities[face].ForEach(_renderer.DrawEntity);
            }

            // Get the list of visible faces.
            //            List<int> visibleFaces = renderer.GetVisibleFaces(camera);
            //
            //            // Iterate over all of the visible faces.
            //            foreach (int face in visibleFaces)
            //            {
            //                // Iterate over all of the renderable entities for each visible face.
            //                try
            //                {
            //                    foreach (RenderableEntity BSPEntity in BSPEntities[face])
            //                    {
            //                        // Render the BSP entity.
            //                        _renderer.DrawEntity (BSPEntity);
            //                    }
            //                }
            //
            //                catch (KeyNotFoundException)
            //                {
            //                    Console.WriteLine ("KeyNotFoundException thrown for face {0}", face);
            //                }
            //            }
        }

        /// <summary>
        /// Load all meshes for this BSP file.
        /// </summary>
        private void LoadAllMeshes()
        {
            // Generate and register all of the meshes in the BSP file.
            Dictionary<int, List<Mesh>> meshes = renderer.GetAllMeshes();

            // Reset the mesh count.
            totalMeshes = 0;

            // Create a new list of renderable entities.
            BSPEntities = new Dictionary<int, List<RenderableEntity>>();

            // Register each mesh with the renderer.
            foreach (KeyValuePair<int, List<Mesh>> meshSet in meshes)
            {
                // Make sure the entry in the dictuinary exists for this face.
                BSPEntities [meshSet.Key] = new List<RenderableEntity> ();

                // Create renderable entities.
                foreach (Mesh mesh in meshSet.Value)
                {
                    string id = string.Format ("{0}{1}", ENTITY_ID, totalMeshes);

                    // Make sure we haven't registered this mesh already.
                    if (_renderer.IsMeshRegistered (id) == false)
                    {
                        // Register the mesh.
                        _renderer.RegisterMesh (id, mesh);

                        // Create a renderable entity for this mesh.
                        RenderableEntity BSPEntity = RenderableEntity.Create ();
                        BSPEntity.Id = id;
                        BSPEntity.Position = Vector3.Zero;
                        BSPEntity.Scale = 0.01f;
                        BSPEntity.Translation = Matrix4.CreateTranslation(0.0f, 0.0f, 0.0f);
                        BSPEntity.Rotation = Vector3.Zero;

                        BSPEntity.Transform = Matrix4.CreateScale(0.05f) * 
                            Matrix4.CreateRotationX (0.0f) * Matrix4.CreateRotationY (0.0f) * Matrix4.CreateRotationZ (0.0f) *
                            Matrix4.CreateTranslation(0.0f, 0.0f, 0.0f);

                        // Add it to our renderable entity dictionary.
                        BSPEntities[meshSet.Key].Add(BSPEntity);

                        // Update the mesh count.
                        totalMeshes++;
                    }
                }
            }
        }

        /// <summary>
        /// Unload all meshes for this BSP file.
        /// </summary>
        private void UnloadAllMeshes()
        {
            if (BSPEntities != null)
            {
                BSPEntities.Clear ();
                BSPEntities = null;
            }

            // Unload all of the meshes from the previous BSP file.
            for (int meshCount = 0; meshCount < totalMeshes; meshCount++)
            {
                string id = string.Format ("{0}{1}", ENTITY_ID, meshCount);

                // Remove the mesh from the renderer.
                if (_renderer.IsMeshRegistered (id) == true)
                {
                    _renderer.UnregisterMesh (id);
                }
            }
        }

        /// <summary>
        /// Load all textures for this BSP file.
        /// </summary>
        private void LoadAllTextures()
        {
            // Make sure a BSP file has been loaded.
            if ((loader == null) || (renderer == null))
            {
                return;
            }

            // Load the notexture texture.
            if ((File.Exists ("textures/notexture.jpg") == true) && (texManager.Registered("textures/notexture.jpg") == false))
            {
                texManager.Add ("textures/notexture.jpg", "textures/notexture.jpg");
            }

            // Iterate through every texture in the BSP and load it.
            foreach (TKQuake.Engine.Loader.BSP.Texture.TextureEntry texture in loader.GetTextures())
            {
                string JPG = texture.name + ".jpg";
                string TGA = texture.name + ".tga";

                // Ignore the noshader textures.
                // TODO: What are these anyway?
                if (texture.name.Contains ("noshader") == false)
                {
                    // Make the sure the texture exists and make sure it has not already been loaded.
                    if ((File.Exists (JPG) == true) && (texManager.Registered(JPG) == false))
                    {
                        texManager.Add (JPG, JPG);
                    }

                    else if ((File.Exists (TGA) == true) && (texManager.Registered(TGA) == false))
                    {
                        texManager.Add (TGA, TGA);
                    }
                }
            }

            for (int face = 0; face < loader.GetFaces().Length; face++)
            {
                Face.FaceEntry currentFace = loader.GetFace(face);

                if (currentFace.lm_index >= 0)
                {
                    byte[,,] lightMap = new byte[currentFace.lm_size[0], currentFace.lm_size[1], 3];

                    LightMap.LightMapEntry map = loader.GetLightMap(currentFace.lm_index);

                    // Make a copy of the relevant part of the light map.
                    for (int x = 0; x < currentFace.lm_size[0]; x++)
                    {
                        for (int y = 0; y < currentFace.lm_size[1]; y++)
                        {
                            lightMap[x, y, 0] = map.map[x + currentFace.lm_start[0], y + currentFace.lm_start[1], 0];
                            lightMap[x, y, 1] = map.map[x + currentFace.lm_start[0], y + currentFace.lm_start[1], 1];
                            lightMap[x, y, 2] = map.map[x + currentFace.lm_start[0], y + currentFace.lm_start[1], 2];
                        }
                    }

                    texManager.AddUV(lightMap, loader.GetFace (face).lm_size, string.Format ("FACE{0}", face));
                }
            }
        }

        /// <summary>
        /// Unload all textures that were loaded for this BSP file.
        /// </summary>
        private void UnloadAllTextures()
        {
            // Make sure a BSP file has been loaded.
            if ((loader == null) || (renderer == null))
            {
                return;
            }

            // Unload the notexture texture.
            if ((File.Exists ("textures/notexture.jpg") == true) && (texManager.Registered("textures/notexture.jpg") == false))
            {
                texManager.Remove ("textures/notexture.jpg");
            }

            // Iterate through every texture in the BSP and unload it.
            foreach (TKQuake.Engine.Loader.BSP.Texture.TextureEntry texture in loader.GetTextures())
            {
                string JPG = texture.name + ".jpg";
                string TGA = texture.name + ".tga";

                // Ignore the noshader textures.
                // TODO: What are these anyway?
                if (texture.name.Contains ("noshader") == false)
                {
                    // Make the sure the texture exists and make sure it has already been loaded.
                    if ((File.Exists (JPG) == true) && (texManager.Registered(JPG) == true))
                    {
                        texManager.Remove (JPG);
                    }

                    else if ((File.Exists (TGA) == true) && (texManager.Registered(TGA) == true))
                    {
                        texManager.Remove (TGA);
                    }
                }
            }
        }

        private Vector3 CheckRayCollisions(Vector3 inputStart, Vector3 inputEnd)
        {
            bool  outputStartsOut = true;
            bool  outputAllSolid  = false;
            float outputFraction  = 1.0f;

            Vector4 start = new Vector4(inputStart, 1.0f);
            Vector4 end   = new Vector4(inputEnd, 1.0f);

            // walk through the BSP tree
            outputFraction = CheckNode(0, 0.0f, 1.0f, start, end, 0.0f, Vector3.Zero, Vector3.Zero, Vector3.Zero);

            // nothing blocked the trace
            if (outputFraction == 1.0f)
            {
                return(inputEnd);
            }

            // collided with something
            else
            {
                return(inputStart + outputFraction * (inputEnd - inputStart));
            }
        }

        private Vector3 CheckSphereCollisions(Vector3 inputStart, Vector3 inputEnd, float radius)
        {
            bool  outputStartsOut = true;
            bool  outputAllSolid  = false;
            float outputFraction  = 1.0f;

            Vector4 start = new Vector4(inputStart, 1.0f);
            Vector4 end   = new Vector4(inputEnd, 1.0f);

            // walk through the BSP tree
            outputFraction = CheckNode(0, 0.0f, 1.0f, start, end, radius, Vector3.Zero, Vector3.Zero, Vector3.Zero);

            // nothing blocked the trace
            if (outputFraction == 1.0f)
            {
                return(inputEnd);
            }

            // collided with something
            else
            {
                return(inputStart + outputFraction * (inputEnd - inputStart));
            }
        }

        private Vector3 CheckBoxCollisions(Vector3 inputStart, Vector3 inputEnd, Vector3 mins, Vector3 maxs)
        {
            if ((mins == Vector3.Zero) && (maxs == Vector3.Zero))
            {
                CheckRayCollisions(inputStart, inputEnd);
            }

            bool  outputStartsOut = true;
            bool  outputAllSolid  = false;
            float outputFraction  = 1.0f;

            Vector4 start   = new Vector4(inputStart, 1.0f);
            Vector4 end     = new Vector4(inputEnd, 1.0f);
            Vector3 extents = new Vector3((-mins[0] > maxs[0]) ? -mins[0] : maxs[0],
                                          (-mins[1] > maxs[1]) ? -mins[1] : maxs[1],
                                          (-mins[2] > maxs[2]) ? -mins[2] : maxs[2]);

            // walk through the BSP tree
            outputFraction = CheckNode(0, 0.0f, 1.0f, start, end, 0.0f, mins, maxs, extents);

            // nothing blocked the trace
            if (outputFraction == 1.0f)
            {
                return(inputEnd);
            }

            // collided with something
            else
            {
                return(inputStart + outputFraction * (inputEnd - inputStart));
            }
        }

        private float CheckNode(int nodeIndex, float startFraction, float endFraction, Vector4 start, Vector4 end, float radius, Vector3 mins, Vector3 maxs, Vector3 extents)
        {
            // this is a leaf
            if (nodeIndex < 0)
            {
                Leaf.LeafEntry leaf = loader.GetLeaf(-(nodeIndex + 1));

                for (int i = 0; i < leaf.n_leafBrushes; i++)
                {
                    Loader.BSP.Brush.BrushEntry brush = loader.GetBrush(loader.GetLeafBrush(leaf.leafBrush + i).brush);

                    // contents & 1 ===> 1 means the brush volume is solid.
                    if ((brush.n_brushSides > 0) && ((loader.GetTexture(brush.texture).contents & 1) == 1))
                    {
                        return(CheckBrush(brush, start, end, radius, mins, maxs, extents));
                    }
                }

                // don't have to do anything else for leaves
                return(0.0f);
            }

            Node.NodeEntry node  = loader.GetNode(nodeIndex);
            Vector4        plane = loader.GetPlane(node.plane).plane;

            float startDistance = Vector4.Dot (start, plane);
            float endDistance = Vector4.Dot (end, plane);

            // this is just a dot product, but we want the absolute values
            if ((mins != Vector3.Zero) && (maxs != Vector3.Zero) && (extents != Vector3.Zero))
            {
                radius  = System.Math.Abs (extents [0] * plane [0]) + System.Math.Abs (extents [1] * plane [1]) + System.Math.Abs (extents [2] * plane [2]);
            }

            // both points are in front of the plane, so check the front child
            if (startDistance >= radius && endDistance >= radius)
            {
                return(CheckNode(node.children[0], startFraction, endFraction, start, end, radius, mins, maxs, extents));
            }

            // both points are behind the plane, so check the back child
            else if (startDistance < -radius && endDistance < -radius)
            {
                return(CheckNode(node.children[1], startFraction, endFraction, start, end, radius, mins, maxs, extents));
            }

            // the line spans the splitting plane
            else
            {
                Vector4 middle;
                int     side;
                float   fraction1, fraction2, middleFraction;
                float   inverseDistance = 1.0f / (startDistance - endDistance);

                // STEP 1: split the segment into two
                if (startDistance < endDistance)
                {
                    side = 1; // back
                    fraction1 = (startDistance - radius + EPSILON) * inverseDistance;
                    fraction2 = (startDistance + radius + EPSILON) * inverseDistance;
                }

                else if (endDistance < startDistance)
                {
                    side = 0; // front
                    fraction1 = (startDistance + radius + EPSILON) * inverseDistance;
                    fraction2 = (startDistance - radius - EPSILON) * inverseDistance;
                }

                else
                {
                    side = 0; // front
                    fraction1 = 1.0f;
                    fraction2 = 0.0f;
                }

                // STEP 2: make sure the numbers are valid
                if (fraction1 < 0.0f)
                {
                    fraction1 = 0.0f;
                }

                else if (fraction1 > 1.0f)
                {
                    fraction1 = 1.0f;
                }

                if (fraction2 < 0.0f)
                {
                    fraction2 = 0.0f;
                }

                else if (fraction2 > 1.0f)
                {
                    fraction2 = 1.0f;
                }

                // STEP 3: calculate the middle point for the first side
                middleFraction = startFraction + (endFraction - startFraction) * fraction1;
                middle = start + fraction1 * (end - start);

                // STEP 4: check the first side
                return(CheckNode(node.children[side], startFraction, middleFraction, start, middle, radius, mins, maxs, extents));

                // STEP 5: calculate the middle point for the second side
                middleFraction = startFraction + (endFraction - startFraction) * fraction2;
                middle = start + fraction2 * (end - start);

                // STEP 6: check the second side
                return(CheckNode(node.children[(side == 1) ? 0 : 1], middleFraction, endFraction, middle, end, radius, mins, maxs, extents));
            }
        }

        private float CheckBrush(Loader.BSP.Brush.BrushEntry brush, Vector4 start, Vector4 end, float radius, Vector3 mins, Vector3 maxs, Vector3 extents)
        {
            float startFraction  = -1.0f;
            float endFraction    = 1.0f;
            float outputFraction = 0.0f;
            bool  startsOut      = false;
            bool  endsOut        = false;

            for (int i = 0; i < brush.n_brushSides; i++)
            {
                Loader.BSP.BrushSide.BrushSideEntry brushSide = loader.GetBrushSide(brush.brushSide + i);
                Vector4                             plane     = loader.GetPlane(brushSide.plane).plane;

                float startDistance, endDistance;

                if ((mins == Vector3.Zero) || (maxs == Vector3.Zero) || (extents == Vector3.Zero))
                {
                    startDistance = Vector4.Dot(start, plane + new Vector4(Vector3.Zero, radius));
                    endDistance   = Vector4.Dot(end,   plane + new Vector4(Vector3.Zero, radius));
                }

                else
                {
                    Vector4 offset = new Vector4((plane[0] < 0) ? maxs[0] : mins[0],
                                                 (plane[1] < 0) ? maxs[1] : mins[1],
                                                 (plane[2] < 0) ? maxs[2] : mins[2],
                                                 0.0f);

                    startDistance = Vector4.Dot(start + offset, plane);
                    endDistance   = Vector4.Dot(end + offset,   plane);
                }

                if (startDistance > 0)
                {
                    startsOut = true;
                }

                if (endDistance > 0)
                {
                    endsOut = true;
                }

                // make sure the trace isn't completely on one side of the brush
                // both are in front of the plane, its outside of this brush
                if (startDistance > 0 && endDistance > 0)
                {
                    return(0.0f);
                }

                // both are behind this plane, it will get clipped by another one
                if (startDistance <= 0 && endDistance <= 0)
                {
                    continue;
                }

                float inverseDistance = 1.0f / (startDistance - endDistance);

                // line is entering into the brush
                if (startDistance > endDistance)
                {
                    float fraction = (startDistance - EPSILON) * inverseDistance;

                    if (fraction > startFraction)
                    {
                        startFraction = fraction;
                    }
                }

                // line is leaving the brush
                else
                {
                    float fraction = (startDistance + EPSILON) * inverseDistance;

                    if (fraction < endFraction)
                    {
                        endFraction = fraction;
                    }
                }
            }


            if (startsOut == false)
            {
//                outputStartOut = false;
//
//                if (endsOut == false)
//                {
//                    outputAllSolid = true;
//                }

                return(0.0f);
            }

            if (startFraction < endFraction)
            {
                if (startFraction > -1 && startFraction < outputFraction)
                {
                    if (startFraction < 0)
                    {
                        startFraction = 0;
                    }

                    outputFraction = startFraction;
                }
            }

            return(outputFraction);
        }
    }
}
